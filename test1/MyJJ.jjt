/**Set Options**/

options
{
  IGNORE_CASE = true;
  MULTI = true;
  VISITOR = true;
  NODE_DEFAULT_VOID=true;
}

PARSER_BEGIN(MyJJ)

import java.io.*;
import java.util.*;

public class MyJJ
{
  public static Hashtable ST = new Hashtable();

  public static void main(String[] args) throws ParseException, FileNotFoundException
  {
    String temp;
    STC temp2;

    if (args.length < 1)
    {
      System.out.println("Please pass in the filename.");
      System.exit(1);
    }

    MyJJ parser = new MyJJ(new FileInputStream(args[0]));

    SimpleNode root = parser.program();

    System.out.println("Abstract Syntax Tree:");

    root.dump(" ");

    System.out.println();
    System.out.println("Symbol Table:");

    Enumeration t = ST.keys();

    while (t.hasMoreElements())
    {
      temp = (String)t.nextElement();
      temp2 = (STC)ST.get(temp);
      System.out.println(temp);
      if (temp2.type != null)
      {
        System.out.println(" type = " + temp2.type);
      }
      if (temp2.value != null)
      {
        System.out.println(" value = " + temp2.value);
      }
    }
    /*
    System.out.println();
    System.out.println("Program:");
    PrintVisitor pv = new PrintVisitor();
    root.jjtAccept(pv, null);

    System.out.println();
    System.out.println("Type Checking:");
    TypeCheckVisitor tc = new TypeCheckVisitor();
    root.jjtAccept(tc, ST);
    */    
  }
}

PARSER_END(MyJJ)


/**Specify the Tokens For Lexical Analysis**/
TOKEN_MGR_DECLS :
{
static int commentNesting = 0;
}
SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
" "
| "\t"
| "\n"
| "\r"
| "\f"
| < "//" (~["\n"])* "\n" >
}
SKIP : /* COMMENTS */
{
"/*" { commentNesting++; } : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
		"/*" { commentNesting++; }
	| 	"*/" { commentNesting--;
	if (commentNesting == 0)
	SwitchTo(DEFAULT);
	}
	| <~[]>
}

TOKEN :{
		<COMMA : ",">
	|	<SEMIC : ";">
	|	<COLON : ":">
	|	<ASSIGN : "=">
	|	<LCHAIN : "{">
	|	<RCHAIN : "}">
	|	<LBR : "(">
	|	<RBR : ")">
	|	<PLUS : "+">
	|	<MINUS : "-">
	|	<UNDERSCORE : "_">
	|	<NOTOP : "~">
	|	<OROP : "||">
	|	<ANDOP : "&&">
	|	<BOOLEQLS : "==">
	|	<NOTEQLS : "!=">
	|	<LESSTHAN : "<">
	|	<GREATERTHAN : ">">
	|	<LESSEQL : "<=">
	|	<GREATEQL : ">=">
	|	<VARIABLE : "var">
	|	<CONSTANT : "const">
	|	<RETURN : "return">
	|	<INTEGER : "integer">
	|	<BOOLEAN : "boolean">
	|	<VOID : "void">
	|	<MAIN : "main">
	|	<IF : "if">
	|	<ELSE : "else">
	|	<TRUE : "true">
	|	<FALSE : "false">
	|	<WHILE : "while">
	|	<SKIPSKIP : "skip">
}

TOKEN :{
	  <NUM : (<DIGIT>) + >
	| < #DIGIT : ("-")? ["0" - "9"]>
	| <ID : <LETTER>(<LETTER> | <UNDERSCORE> | <DIGIT>)*>
	| < #LETTER : ["a" - "z", "A" - "Z"]>
}

TOKEN :{
	<OTHER : ~[]>
}

/**PRODUCTION RULES**/
SimpleNode program() #Program : {}{
	decl_list()
	function_list()
	main()
	<EOF>
	{return jjtThis;}
}

void decl_list() #void : {}{
	(decl() <SEMIC> decl_list())?
}

void decl() #Decl : {}{
	(var_decl() | const_decl())
}

void var_decl() #Var_decl : {Token t; String name;}{
	t = <VARIABLE> name = id() {jjtThis.value = t.image;} <COLON> type()
}

void const_decl() #Const_decl : {Token t; String name;}{
	t = <CONSTANT> name = id() {jjtThis.value = t.image;} <COLON> type() <ASSIGN> expression() #ASSIGN(2)
}

void function_list() #void : {}{
	(function() function_list())?
}

void function() #Function : {}{
	type() id() <LBR> parameter_list() <RBR>
	<LCHAIN>
		decl_list()
		statement_block()
		<RETURN> <LBR> (expression())? <RBR> <SEMIC> /**ARE BRACKETS IN THE RIGHT PLACE?**/
	<RCHAIN>
}


void type () : {Token t;}{
	  t = <INTEGER> {jjtThis.value = t.image;} 
	| t = <BOOLEAN> {jjtThis.value = t.image;}
	| t = <VOID> {jjtThis.value = t.image;}
}

void parameter_list() #void : {}{
	(nemp_parameter_list())?
}

void nemp_parameter_list() #void : {}{
	id() <COLON> (type() [<COMMA> nemp_parameter_list()]) /*****************CHANGED*******************/
}

void main() : {}{
	[
	<MAIN>
	<LCHAIN>
		decl_list()
		statement_block()
	<RCHAIN>
	]
}

void statement_block() #void : {}{
	(statement() #STM(1) statement_block())?
}

void statement() : {}{
		id() 
		(
				<ASSIGN> expression() <SEMIC> //#ASSIGN(2) 
			|	<LBR> arg_list() <RBR> <SEMIC>
		)	
	|	<LCHAIN> statement_block() <RCHAIN>
	|	<IF> condition() <LCHAIN> statement_block() <RCHAIN> [<ELSE> <LCHAIN> statement_block() <RCHAIN>]
	|	<WHILE> condition() <LCHAIN> statement_block() <RCHAIN>
	|	<SKIPSKIP> <SEMIC>
}

/***************************************************************************************************************/
/*******************************************EXPRESSION RULE*****************************************************/
/***************************************************************************************************************/

/*********************ORIGINAL***********************/
/*
void expression() : {}{
		fragment() binary_arith_op() fragment()
	|	<LBR> expression() <RBR>
	|	<ID> <LBR> arg_list() <RBR>
	|	fragment()
}
*/

void expression() #void : {}{
		fragment() [binary_arith_op() expression()]	
}

void binary_arith_op(): {Token t;}{
	  t = <PLUS> {jjtThis.value = t.image;}
	| t = <MINUS> {jjtThis.value = t.image;}
}

/*********************ORIGINAL***********************/
/*
void fragment() : {}{
		<ID>
	|	<MINUS> <ID>
	|	<NUM>
	|	<TRUE>
	|	<FALSE>
	|	expression()
}
*/

void fragment() #void : {}{
		id()
		(
			[<LBR> arg_list() <RBR>]
		)
	|	number()
	|	<TRUE>
	|	<FALSE>
	|	<MINUS> fragment()
}

/***************************************************************************************************************/
/*******************************************CONDITION RULE******************************************************/
/***************************************************************************************************************/

/*********************ORIGINAL***********************/
/*
void condition() : {}{
		<NOTOP> condition()
	|	<LBR> condition() <RBR>
	|	expression() comp_op() expression()
	|	condition() <LBR> <OROP> | <ANDOP> <RBR> condition()
}
*/

/********************EDITED***************************/
void condition() : {}{
		<NOTOP> condition() 
	|	<LBR> condition() <RBR> [conditionPrime()]
	|	expression() comp_op() expression() [conditionPrime()]
}

void conditionPrime() #void : {}{
	(<ANDOP> | <OROP>) condition()
}

void comp_op() : {Token t;}{
		<BOOLEQLS>
	|	<NOTEQLS>
	|	<LESSTHAN>
	|	<LESSEQL>
	|	<GREATERTHAN>
	|	<GREATEQL>
}

void arg_list() #void : {}{
	(nemp_arg_list())?
}

void nemp_arg_list() #void : {}{
	<ID> [(<COMMA> nemp_arg_list())]
}

void id() : {Token t;}
{
  t = <ID> {jjtThis.value = t.image;}
}

void number() : {Token t;}{
	t = <NUM> {jjtThis.value = t.image;}
}

void true1() : {Token t;}{
	t = <TRUE> {jjtThis.value = t.image;}
}