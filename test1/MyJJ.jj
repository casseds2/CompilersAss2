/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. MyJJ.jj */
/*@egen*//**Set Options**/

options
{
  IGNORE_CASE = true;
               
                 
                         
}

PARSER_BEGIN(MyJJ)

import java.io.*;
import java.util.*;

public class MyJJ/*@bgen(jjtree)*/implements MyJJTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTMyJJState jjtree = new JJTMyJJState();

/*@egen*/
  public static Hashtable ST = new Hashtable();

  public static void main(String[] args) throws ParseException, FileNotFoundException
  {
    String temp;
    STC temp2;

    if (args.length < 1)
    {
      System.out.println("Please pass in the filename.");
      System.exit(1);
    }

    MyJJ parser = new MyJJ(new FileInputStream(args[0]));

    SimpleNode root = parser.program();

    System.out.println("Abstract Syntax Tree:");

    root.dump(" ");

    System.out.println();
    System.out.println("Symbol Table:");

    Enumeration t = ST.keys();

    while (t.hasMoreElements())
    {
      temp = (String)t.nextElement();
      temp2 = (STC)ST.get(temp);
      System.out.println(temp);
      if (temp2.type != null)
      {
        System.out.println(" type = " + temp2.type);
      }
      if (temp2.value != null)
      {
        System.out.println(" value = " + temp2.value);
      }
    }
    /*
    System.out.println();
    System.out.println("Program:");
    PrintVisitor pv = new PrintVisitor();
    root.jjtAccept(pv, null);

    System.out.println();
    System.out.println("Type Checking:");
    TypeCheckVisitor tc = new TypeCheckVisitor();
    root.jjtAccept(tc, ST);
    */    
  }
}

PARSER_END(MyJJ)


/**Specify the Tokens For Lexical Analysis**/
TOKEN_MGR_DECLS :
{
static int commentNesting = 0;
}
SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
" "
| "\t"
| "\n"
| "\r"
| "\f"
| < "//" (~["\n"])* "\n" >
}
SKIP : /* COMMENTS */
{
"/*" { commentNesting++; } : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
		"/*" { commentNesting++; }
	| 	"*/" { commentNesting--;
	if (commentNesting == 0)
	SwitchTo(DEFAULT);
	}
	| <~[]>
}

TOKEN :{
		<COMMA : ",">
	|	<SEMIC : ";">
	|	<COLON : ":">
	|	<ASSIGN : "=">
	|	<LCHAIN : "{">
	|	<RCHAIN : "}">
	|	<LBR : "(">
	|	<RBR : ")">
	|	<PLUS : "+">
	|	<MINUS : "-">
	|	<UNDERSCORE : "_">
	|	<NOTOP : "~">
	|	<OROP : "||">
	|	<ANDOP : "&&">
	|	<BOOLEQLS : "==">
	|	<NOTEQLS : "!=">
	|	<LESSTHAN : "<">
	|	<GREATERTHAN : ">">
	|	<LESSEQL : "<=">
	|	<GREATEQL : ">=">
	|	<VARIABLE : "var">
	|	<CONSTANT : "const">
	|	<RETURN : "return">
	|	<INTEGER : "integer">
	|	<BOOLEAN : "boolean">
	|	<VOID : "void">
	|	<MAIN : "main">
	|	<IF : "if">
	|	<ELSE : "else">
	|	<TRUE : "true">
	|	<FALSE : "false">
	|	<WHILE : "while">
	|	<SKIPSKIP : "skip">
}

TOKEN :{
	  <NUM : (<DIGIT>) + >
	| < #DIGIT : ("-")? ["0" - "9"]>
	| <ID : <LETTER>(<LETTER> | <UNDERSCORE> | <DIGIT>)*>
	| < #LETTER : ["a" - "z", "A" - "Z"]>
}

TOKEN :{
	<OTHER : ~[]>
}

/**PRODUCTION RULES**/
SimpleNode program()          : {/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Program */
        try {
/*@egen*/
	decl_list()
	function_list()
	main()
	<EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{return jjtn000;}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void decl_list()       : {}{
	(decl() <SEMIC> decl_list())?
}

void decl()       : {/*@bgen(jjtree) Decl */
  ASTDecl jjtn000 = new ASTDecl(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Decl */
        try {
/*@egen*/
	(var_decl() | const_decl())/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void var_decl()           : {/*@bgen(jjtree) Var_decl */
                             ASTVar_decl jjtn000 = new ASTVar_decl(JJTVAR_DECL);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String name;}{/*@bgen(jjtree) Var_decl */
        try {
/*@egen*/
	t = <VARIABLE> name = id() {jjtn000.value = t.image;} <COLON> type()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void const_decl()             : {/*@bgen(jjtree) Const_decl */
                                 ASTConst_decl jjtn000 = new ASTConst_decl(JJTCONST_DECL);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String name;}{/*@bgen(jjtree) Const_decl */
        try {
/*@egen*/
	t = <CONSTANT> name = id() {jjtn000.value = t.image;} <COLON> type() <ASSIGN>/*@bgen(jjtree) #ASSIGN( 2) */
                                                                                      {
                                                                                        ASTASSIGN jjtn001 = new ASTASSIGN(JJTASSIGN);
                                                                                        boolean jjtc001 = true;
                                                                                        jjtree.openNodeScope(jjtn001);
                                                                                      }
                                                                                      try {
/*@egen*/ expression()/*@bgen(jjtree)*/
                                                                                      } catch (Throwable jjte001) {
                                                                                        if (jjtc001) {
                                                                                          jjtree.clearNodeScope(jjtn001);
                                                                                          jjtc001 = false;
                                                                                        } else {
                                                                                          jjtree.popNode();
                                                                                        }
                                                                                        if (jjte001 instanceof RuntimeException) {
                                                                                          throw (RuntimeException)jjte001;
                                                                                        }
                                                                                        if (jjte001 instanceof ParseException) {
                                                                                          throw (ParseException)jjte001;
                                                                                        }
                                                                                        throw (Error)jjte001;
                                                                                      } finally {
                                                                                        if (jjtc001) {
                                                                                          jjtree.closeNodeScope(jjtn001,  2);
                                                                                        }
                                                                                      }
/*@egen*/           /*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void function_list()       : {}{
	(function() function_list())?
}

void function()           : {/*@bgen(jjtree) Function */
  ASTFunction jjtn000 = new ASTFunction(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Function */
        try {
/*@egen*/
	type() id() <LBR> parameter_list() <RBR>
	<LCHAIN>
		decl_list()
		statement_block()
		<RETURN> <LBR> (expression())? <RBR> <SEMIC> /**ARE BRACKETS IN THE RIGHT PLACE?**/
	<RCHAIN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void type () : {Token t;}{
	  t = <INTEGER> {jjtn000.value = t.image;} 
	| t = <BOOLEAN> {jjtn000.value = t.image;}
	| t = <VOID> {jjtn000.value = t.image;}
}

void parameter_list()       : {}{
	(nemp_parameter_list())?
}

void nemp_parameter_list()       : {}{
	id() <COLON> (type() [<COMMA> nemp_parameter_list()]) /*****************CHANGED*******************/
}

void main() : {}{
	[
	<MAIN>
	<LCHAIN>
		decl_list()
		statement_block()
	<RCHAIN>
	]
}

void statement_block()       : {}{
	(/*@bgen(jjtree) #STM( 1) */
         {
           ASTSTM jjtn001 = new ASTSTM(JJTSTM);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
         }
         try {
/*@egen*/statement()/*@bgen(jjtree)*/
         } catch (Throwable jjte001) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte001 instanceof RuntimeException) {
             throw (RuntimeException)jjte001;
           }
           if (jjte001 instanceof ParseException) {
             throw (ParseException)jjte001;
           }
           throw (Error)jjte001;
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  1);
           }
         }
/*@egen*/         statement_block())?
}

void statement() : {}{
		id() 
		(
				<ASSIGN> expression() <SEMIC> //#ASSIGN(2) 
			|	<LBR> arg_list() <RBR> <SEMIC>
		)	
	|	<LCHAIN> statement_block() <RCHAIN>
	|	<IF> condition() <LCHAIN> statement_block() <RCHAIN> [<ELSE> <LCHAIN> statement_block() <RCHAIN>]
	|	<WHILE> condition() <LCHAIN> statement_block() <RCHAIN>
	|	<SKIPSKIP> <SEMIC>
}

/***************************************************************************************************************/
/*******************************************EXPRESSION RULE*****************************************************/
/***************************************************************************************************************/

/*********************ORIGINAL***********************/
/*
void expression() : {}{
		fragment() binary_arith_op() fragment()
	|	<LBR> expression() <RBR>
	|	<ID> <LBR> arg_list() <RBR>
	|	fragment()
}
*/

void expression()       : {}{
		fragment() [binary_arith_op() expression()]	
}

void binary_arith_op(): {Token t;}{
	  t = <PLUS> {jjtn000.value = t.image;}
	| t = <MINUS> {jjtn000.value = t.image;}
}

/*********************ORIGINAL***********************/
/*
void fragment() : {}{
		<ID>
	|	<MINUS> <ID>
	|	<NUM>
	|	<TRUE>
	|	<FALSE>
	|	expression()
}
*/

void fragment()       : {}{
		id()
		(
			[<LBR> arg_list() <RBR>]
		)
	|	number()
	|	<TRUE>
	|	<FALSE>
	|	<MINUS> fragment()
}

/***************************************************************************************************************/
/*******************************************CONDITION RULE******************************************************/
/***************************************************************************************************************/

/*********************ORIGINAL***********************/
/*
void condition() : {}{
		<NOTOP> condition()
	|	<LBR> condition() <RBR>
	|	expression() comp_op() expression()
	|	condition() <LBR> <OROP> | <ANDOP> <RBR> condition()
}
*/

/********************EDITED***************************/
void condition() : {}{
		<NOTOP> condition() 
	|	<LBR> condition() <RBR> [conditionPrime()]
	|	expression() comp_op() expression() [conditionPrime()]
}

void conditionPrime()       : {}{
	(<ANDOP> | <OROP>) condition()
}

void comp_op() : {Token t;}{
		<BOOLEQLS>
	|	<NOTEQLS>
	|	<LESSTHAN>
	|	<LESSEQL>
	|	<GREATERTHAN>
	|	<GREATEQL>
}

void arg_list()       : {}{
	(nemp_arg_list())?
}

void nemp_arg_list()       : {}{
	<ID> [(<COMMA> nemp_arg_list())]
}

void id() : {Token t;}
{
  t = <ID> {jjtn000.value = t.image;}
}

void number() : {Token t;}{
	t = <NUM> {jjtn000.value = t.image;}
}

void true1() : {Token t;}{
	t = <TRUE> {jjtn000.value = t.image;}
}