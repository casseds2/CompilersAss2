/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. MyJJ.jj */
/*@egen*/options
{
  IGNORE_CASE = false;
             
                 
}

PARSER_BEGIN(MyJJ)

import java.io.*;
import java.util.*;

public class MyJJ/*@bgen(jjtree)*/implements MyJJTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTMyJJState jjtree = new JJTMyJJState();

/*@egen*/
  //public static Hashtable ST = new Hashtable();

  public static void main(String[] args) throws ParseException, FileNotFoundException
  {
    String temp;
    //STC temp2;

    if (args.length < 1)
    {
      System.out.println("Please pass in the filename.");
      System.exit(1);
    }

    MyJJ parser = new MyJJ(new FileInputStream(args[0]));

    SimpleNode root = parser.program();

    System.out.println("Abstract Syntax Tree:");

    root.dump(" ");

    System.out.println();
    //System.out.println("Symbol Table:");

    //Enumeration t = ST.keys();
    /*
    while (t.hasMoreElements())
    {
      temp = (String)t.nextElement();
      temp2 = (STC)ST.get(temp);
      System.out.println(temp);
      if (temp2.type != null)
      {
        System.out.println(" type = " + temp2.type);
      }
      if (temp2.value != null)
      {
        System.out.println(" value = " + temp2.value);
      }
    }

    System.out.println();
    System.out.println("Program:");
    PrintVisitor pv = new PrintVisitor();
    root.jjtAccept(pv, null);

    System.out.println();
    System.out.println("Type Checking:");
    TypeCheckVisitor tc = new TypeCheckVisitor();
    root.jjtAccept(tc, ST);    
    */
  }
}

PARSER_END(MyJJ)

//********************************************START OF TOKENS*******************************************************//
/**Specify the Tokens For Lexical Analysis**/
TOKEN_MGR_DECLS :
{
static int commentNesting = 0;
}
SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
" "
| "\t"
| "\n"
| "\r"
| "\f"
| < "//" (~["\n"])* "\n" >
}
SKIP : /* COMMENTS */
{
"/*" { commentNesting++; } : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
    "/*" { commentNesting++; }
  |   "*/" { commentNesting--;
  if (commentNesting == 0)
  SwitchTo(DEFAULT);
  }
  | <~[]>
}

TOKEN :{
    <COMMA      : ",">
  | <SEMIC      : ";">
  | <COLON      : ":">
  | <ASSIGN     : "=">
  | <LCHAIN     : "{">
  | <RCHAIN     : "}">
  | <LBR        : "(">
  | <RBR        : ")">
  | <PLUS       : "+">
  | <MINUS      : "-">
  | <UNDERSCORE : "_">
  | <NOTOP      : "~">
  | <OROP       : "||">
  | <ANDOP      : "&&">
  | <BOOLEQLS   : "==">
  | <NOTEQLS    : "!=">
  | <LESSTHAN   : "<">
  | <GREATERTHAN : ">">
  | <LESSEQL    :  "<=">
  | <GREATEQL   : ">=">
  | <VARIABLE   : "var">
  | <CONSTANT   : "const">
  | <RETURN     : "return">
  | <INTEGER    : "integer">
  | <BOOLEAN    : "boolean">
  | <VOID       : "void">
  | <MAIN       : "main">
  | <IF         : "if">
  | <ELSE       : "else">
  | <TRUE       : "true">
  | <FALSE      : "false">
  | <WHILE      : "while">
  | <SKIPSKIP   : "skip">
}

TOKEN :{
    <NUM : (<DIGIT>) + >
  | < #DIGIT : ("-")? ["0" - "9"]>
  | <ID : <LETTER>(<LETTER> | <UNDERSCORE> | <DIGIT>)*>
  | < #LETTER : ["a" - "z", "A" - "Z"]>
}

TOKEN :{
  <OTHER : ~[]>
}
//*******************************************END OF TOKENS********************************************//


//If no #VOID, Rule Name is the name of the created node

/**PRODUCTION RULES**/
SimpleNode program()          : {/*@bgen(jjtree) PROGRAM */
  ASTPROGRAM jjtn000 = new ASTPROGRAM(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) PROGRAM */
  try {
/*@egen*/
  decl_list()
  function_list()
  main()
  <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void decl_list()       : {}{
  (decl() <SEMIC> [/*@bgen(jjtree) #Decls( 2) */
                   {
                     ASTDecls jjtn001 = new ASTDecls(JJTDECLS);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
                   }
                   try {
/*@egen*/decl_list()/*@bgen(jjtree)*/
                   } catch (Throwable jjte001) {
                     if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte001 instanceof RuntimeException) {
                       throw (RuntimeException)jjte001;
                     }
                     if (jjte001 instanceof ParseException) {
                       throw (ParseException)jjte001;
                     }
                     throw (Error)jjte001;
                   } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  2);
                     }
                   }
/*@egen*/          ] )  /**SHOULD I ADD #decl_list(2) after this as its optional?**/
}

void decl() : {/*@bgen(jjtree) decl */
  ASTdecl jjtn000 = new ASTdecl(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) decl */
  try {
/*@egen*/
  var_decl() | const_decl()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void var_decl()     : {/*@bgen(jjtree) VAR */
  ASTVAR jjtn000 = new ASTVAR(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) VAR */
  try {
/*@egen*/
  <VARIABLE> id() <COLON>/*@bgen(jjtree) #Decl( 1) */
                          {
                            ASTDecl jjtn001 = new ASTDecl(JJTDECL);
                            boolean jjtc001 = true;
                            jjtree.openNodeScope(jjtn001);
                          }
                          try {
/*@egen*/ type()/*@bgen(jjtree)*/
                          } catch (Throwable jjte001) {
                            if (jjtc001) {
                              jjtree.clearNodeScope(jjtn001);
                              jjtc001 = false;
                            } else {
                              jjtree.popNode();
                            }
                            if (jjte001 instanceof RuntimeException) {
                              throw (RuntimeException)jjte001;
                            }
                            if (jjte001 instanceof ParseException) {
                              throw (ParseException)jjte001;
                            }
                            throw (Error)jjte001;
                          } finally {
                            if (jjtc001) {
                              jjtree.closeNodeScope(jjtn001,  1);
                            }
                          }
/*@egen*/         /*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void const_decl()        : {/*@bgen(jjtree) CONST */
  ASTCONST jjtn000 = new ASTCONST(JJTCONST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) CONST */
  try {
/*@egen*/
  <CONSTANT> id() <COLON> type() <ASSIGN>/*@bgen(jjtree) #Decl( 1) */
                                          {
                                            ASTDecl jjtn001 = new ASTDecl(JJTDECL);
                                            boolean jjtc001 = true;
                                            jjtree.openNodeScope(jjtn001);
                                          }
                                          try {
/*@egen*/ expression()/*@bgen(jjtree)*/
                                          } catch (Throwable jjte001) {
                                            if (jjtc001) {
                                              jjtree.clearNodeScope(jjtn001);
                                              jjtc001 = false;
                                            } else {
                                              jjtree.popNode();
                                            }
                                            if (jjte001 instanceof RuntimeException) {
                                              throw (RuntimeException)jjte001;
                                            }
                                            if (jjte001 instanceof ParseException) {
                                              throw (ParseException)jjte001;
                                            }
                                            throw (Error)jjte001;
                                          } finally {
                                            if (jjtc001) {
                                              jjtree.closeNodeScope(jjtn001,  1);
                                            }
                                          }
/*@egen*/         /*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void function_list()       : {}{ //Dont want to create a node as its done in function()
  (function() function_list())?
}

void function()           : {/*@bgen(jjtree) FUNCTION */
  ASTFUNCTION jjtn000 = new ASTFUNCTION(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) FUNCTION */
  try {
/*@egen*/
  type() id() <LBR> parameter_list() <RBR>
  <LCHAIN>
    decl_list()
    statement_block()
    <RETURN> <LBR> (expression())? <RBR> <SEMIC>
  <RCHAIN>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void type ()       : {/*@bgen(jjtree) TYPE */
                      ASTTYPE jjtn000 = new ASTTYPE(JJTTYPE);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) TYPE */
  try {
/*@egen*/
  t = <INTEGER>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <BOOLEAN>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <VOID>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

void parameter_list()             : {/*@bgen(jjtree) PARAMSLIST */
  ASTPARAMSLIST jjtn000 = new ASTPARAMSLIST(JJTPARAMSLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) PARAMSLIST */
  try {
/*@egen*/ //No void, want to see parameter_list Appear as a node
  (nemp_parameter_list())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void nemp_parameter_list()       : {}{ //dont want to create a node, its done in id() and type()
  id() <COLON> (type() [<COMMA> nemp_parameter_list()]) /**SHOULD I ADD #nemp_parameter_list(2) after this as its optional?**/
}

void main()       : {/*@bgen(jjtree) MAIN */
  ASTMAIN jjtn000 = new ASTMAIN(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) MAIN */
  try {
/*@egen*/
  [
  <MAIN>
  <LCHAIN>
    decl_list()
    statement_block()
  <RCHAIN>
  ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statement_block()       : {}{
  (statement() statement_block())?
}

void statement()        : {/*@bgen(jjtree) STATE */
  ASTSTATE jjtn000 = new ASTSTATE(JJTSTATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) STATE */
    try {
/*@egen*/ //Node will be created called statement
    id() 
    (
        <ASSIGN> expression() <SEMIC> 
      | <LBR> arg_list() <RBR> <SEMIC>
    ) 
  |/*@bgen(jjtree) OPENSTATEMENTBLOCK */
    {
      ASTOPENSTATEMENTBLOCK jjtn001 = new ASTOPENSTATEMENTBLOCK(JJTOPENSTATEMENTBLOCK);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/ <LCHAIN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/                     statement_block()/*@bgen(jjtree) CLOSESTATEMENTBLOCK */
                                                   {
                                                     ASTCLOSESTATEMENTBLOCK jjtn002 = new ASTCLOSESTATEMENTBLOCK(JJTCLOSESTATEMENTBLOCK);
                                                     boolean jjtc002 = true;
                                                     jjtree.openNodeScope(jjtn002);
                                                   }
                                                   try {
/*@egen*/ <RCHAIN>/*@bgen(jjtree)*/
                                                   } finally {
                                                     if (jjtc002) {
                                                       jjtree.closeNodeScope(jjtn002, true);
                                                     }
                                                   }
/*@egen*/                     
  | if1() condition() <LCHAIN> statement_block() <RCHAIN> [/*@bgen(jjtree) ELSE */
                                                           {
                                                             ASTELSE jjtn003 = new ASTELSE(JJTELSE);
                                                             boolean jjtc003 = true;
                                                             jjtree.openNodeScope(jjtn003);
                                                           }
                                                           try {
/*@egen*/<ELSE>/*@bgen(jjtree)*/
                                                           } finally {
                                                             if (jjtc003) {
                                                               jjtree.closeNodeScope(jjtn003, true);
                                                             }
                                                           }
/*@egen*/       <LCHAIN> statement_block() <RCHAIN>] /*****OPTION TO ELSE???*****/
  |/*@bgen(jjtree) WHILE */
    {
      ASTWHILE jjtn004 = new ASTWHILE(JJTWHILE);
      boolean jjtc004 = true;
      jjtree.openNodeScope(jjtn004);
    }
    try {
/*@egen*/ <WHILE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc004) {
        jjtree.closeNodeScope(jjtn004, true);
      }
    }
/*@egen*/        condition() <LCHAIN> statement_block() <RCHAIN>
  | <SKIPSKIP> <SEMIC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/***************************************************************************************************************/
/*******************************************EXPRESSION RULE*****************************************************/
/***************************************************************************************************************/

/*********************ORIGINAL***********************/
/*
void expression() : {}{
    fragment() binary_arith_op() fragment()
  | <LBR> expression() <RBR>
  | ID() <LBR> arg_list() <RBR>
  | fragment()
}
*/

void expression()       : {}{
    fragment() [binary_arith_op() expression()] 
}

void binary_arith_op()        : {/*@bgen(jjtree) BINOP */
                                 ASTBINOP jjtn000 = new ASTBINOP(JJTBINOP);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) BINOP */
    try {
/*@egen*/
    t = <PLUS>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.value = t.image;} 
    | t = <MINUS>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*********************ORIGINAL***********************/
/*
void fragment() : {}{
    ID()
  | <MINUS> <ID>
  | <NUM>
  | <TRUE>
  | <FALSE>
  | expression()
}
*/

void fragment()       : {}{ //Insert Token t
    id()
    (
      [<LBR> arg_list() <RBR>]
    )
  |/*@bgen(jjtree) NUM */
    {
      ASTNUM jjtn001 = new ASTNUM(JJTNUM);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/ <NUM>/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/     
  |/*@bgen(jjtree) TRUE */
    {
      ASTTRUE jjtn002 = new ASTTRUE(JJTTRUE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/ <TRUE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/      
  |/*@bgen(jjtree) FALSE */
    {
      ASTFALSE jjtn003 = new ASTFALSE(JJTFALSE);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
    }
    try {
/*@egen*/ <FALSE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003, true);
      }
    }
/*@egen*/       
  |/*@bgen(jjtree) MINUS */
    {
      ASTMINUS jjtn004 = new ASTMINUS(JJTMINUS);
      boolean jjtc004 = true;
      jjtree.openNodeScope(jjtn004);
    }
    try {
/*@egen*/ <MINUS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc004) {
        jjtree.closeNodeScope(jjtn004, true);
      }
    }
/*@egen*/        fragment()
}

/***************************************************************************************************************/
/*******************************************CONDITION RULE******************************************************/
/***************************************************************************************************************/

/*********************ORIGINAL***********************/
/*
void condition() : {}{
    <NOTOP> condition()
  | <LBR> condition() <RBR>
  | expression() comp_op() expression()
  | condition() <LBR> <OROP> | <ANDOP> <RBR> condition()
}
*/

/********************EDITED***************************/
void condition()       : {}{
    <NOTOP> condition() 
  | <LBR> condition() <RBR> [conditionPrime()]
  | expression() comp_op() expression() [conditionPrime()]
}

void conditionPrime()        : {/*@bgen(jjtree) ANDOR */
  ASTANDOR jjtn000 = new ASTANDOR(JJTANDOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) ANDOR */
  try {
/*@egen*/
  (<ANDOP> | <OROP>) condition()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void comp_op()         : {/*@bgen(jjtree) COMPOP */
                          ASTCOMPOP jjtn000 = new ASTCOMPOP(JJTCOMPOP);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) COMPOP */
    try {
/*@egen*/
    t = <BOOLEQLS>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <NOTEQLS>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <LESSTHAN>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <LESSEQL>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <GREATERTHAN>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <GREATEQL>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void arg_list()               : {/*@bgen(jjtree) ARGUMENTSLIST */
  ASTARGUMENTSLIST jjtn000 = new ASTARGUMENTSLIST(JJTARGUMENTSLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) ARGUMENTSLIST */
  try {
/*@egen*/
  (nemp_arg_list())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void nemp_arg_list()       : {}{
  id() [(<COMMA> nemp_arg_list())]
}

void id()     : {/*@bgen(jjtree) ID */
                 ASTID jjtn000 = new ASTID(JJTID);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;} {/*@bgen(jjtree) ID */
  try {
/*@egen*/
  t = <ID>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void if1()     : {/*@bgen(jjtree) IF */
  ASTIF jjtn000 = new ASTIF(JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) IF */
  try {
/*@egen*/
  <IF>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void number() : {/*@bgen(jjtree) number */
                 ASTnumber jjtn000 = new ASTnumber(JJTNUMBER);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) number */
  try {
/*@egen*/
  t = <NUM>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}