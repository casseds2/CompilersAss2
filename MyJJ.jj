/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. MyJJ.jj */
/*@egen*/options
{
  IGNORE_CASE = false;
             
                 
}

PARSER_BEGIN(MyJJ)

import java.io.*;
import java.util.*;

public class MyJJ/*@bgen(jjtree)*/implements MyJJTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTMyJJState jjtree = new JJTMyJJState();

/*@egen*/
  //public static Hashtable ST = new Hashtable();

  public static void main(String[] args) throws ParseException, FileNotFoundException
  {
    String temp;
    //STC temp2;

    if (args.length < 1)
    {
      System.out.println("Please pass in the filename.");
      System.exit(1);
    }

    MyJJ parser = new MyJJ(new FileInputStream(args[0]));

    SimpleNode root = parser.program();

    System.out.println("Abstract Syntax Tree:");

    root.dump(" ");

    System.out.println();
    //System.out.println("Symbol Table:");

    //Enumeration t = ST.keys();
    /*
    while (t.hasMoreElements())
    {
      temp = (String)t.nextElement();
      temp2 = (STC)ST.get(temp);
      System.out.println(temp);
      if (temp2.type != null)
      {
        System.out.println(" type = " + temp2.type);
      }
      if (temp2.value != null)
      {
        System.out.println(" value = " + temp2.value);
      }
    }

    System.out.println();
    System.out.println("Program:");
    PrintVisitor pv = new PrintVisitor();
    root.jjtAccept(pv, null);

    System.out.println();
    System.out.println("Type Checking:");
    TypeCheckVisitor tc = new TypeCheckVisitor();
    root.jjtAccept(tc, ST);    
    */
  }
}

PARSER_END(MyJJ)

//********************************************START OF TOKENS*******************************************************//
/**Specify the Tokens For Lexical Analysis**/
TOKEN_MGR_DECLS :
{
static int commentNesting = 0;
}
SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
" "
| "\t"
| "\n"
| "\r"
| "\f"
| < "//" (~["\n"])* "\n" >
}
SKIP : /* COMMENTS */
{
"/*" { commentNesting++; } : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
    "/*" { commentNesting++; }
  |   "*/" { commentNesting--;
  if (commentNesting == 0)
  SwitchTo(DEFAULT);
  }
  | <~[]>
}

TOKEN :{
    <COMMA      : ",">
  | <SEMIC      : ";">
  | <COLON      : ":">
  | <ASSIGN     : "=">
  | <LCHAIN     : "{">
  | <RCHAIN     : "}">
  | <LBR        : "(">
  | <RBR        : ")">
  | <PLUS       : "+">
  | <MINUS      : "-">
  | <UNDERSCORE : "_">
  | <NOTOP      : "~">
  | <OROP       : "||">
  | <ANDOP      : "&&">
  | <BOOLEQLS   : "==">
  | <NOTEQLS    : "!=">
  | <LESSTHAN   : "<">
  | <GREATERTHAN : ">">
  | <LESSEQL    :  "<=">
  | <GREATEQL   : ">=">
  | <VARIABLE   : "var">
  | <CONSTANT   : "const">
  | <RETURN     : "return">
  | <INTEGER    : "integer">
  | <BOOLEAN    : "boolean">
  | <VOID       : "void">
  | <MAIN       : "main">
  | <IF         : "if">
  | <ELSE       : "else">
  | <TRUE       : "true">
  | <FALSE      : "false">
  | <WHILE      : "while">
  | <SKIPSKIP   : "skip">
}

TOKEN :{
    <NUM : (<DIGIT>) + >
  | < #DIGIT : ("-")? ["0" - "9"]>
  | <ID : <LETTER>(<LETTER> | <UNDERSCORE> | <DIGIT>)*>
  | < #LETTER : ["a" - "z", "A" - "Z"]>
}

TOKEN :{
  <OTHER : ~[]>
}
//*******************************************END OF TOKENS********************************************//


//If no #VOID, Rule Name is the name of the created node

/**PRODUCTION RULES**/
SimpleNode program()          : {/*@bgen(jjtree) PROGRAM */
  ASTPROGRAM jjtn000 = new ASTPROGRAM(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) PROGRAM */
  try {
/*@egen*/
  decl_list()
  function_list()
  main()
  <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void decl_list()       : {}{
  (decl() <SEMIC> decl_list())*  /**SHOULD I ADD #decl_list(2) after this as its optional?**/
}

void decl()       : {}{
  var_decl() | const_decl()
}

void var_decl()     : {/*@bgen(jjtree) VAR */
  ASTVAR jjtn000 = new ASTVAR(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) VAR */
  try {
/*@egen*/
  <VARIABLE> id() <COLON> type()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void const_decl()        : {/*@bgen(jjtree) CONST */
  ASTCONST jjtn000 = new ASTCONST(JJTCONST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) CONST */
  try {
/*@egen*/
  <CONSTANT> id() <COLON> type() <ASSIGN> expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void function_list()       : {}{ //Dont want to create a node as its done in function()
  (function() function_list())?
}

void function()           : {/*@bgen(jjtree) FUNCTION */
  ASTFUNCTION jjtn000 = new ASTFUNCTION(JJTFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) FUNCTION */
  try {
/*@egen*/
  type() id() <LBR> parameter_list() <RBR>
  <LCHAIN>
    decl_list()
    statement_block()
    <RETURN> <LBR> (expression())? <RBR> <SEMIC>
  <RCHAIN>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void type ()       : {/*@bgen(jjtree) TYPE */
                      ASTTYPE jjtn000 = new ASTTYPE(JJTTYPE);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) TYPE */
  try {
/*@egen*//*@bgen(jjtree) INT */
  {
    ASTINT jjtn001 = new ASTINT(JJTINT);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/
  t = <INTEGER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/     /*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {jjtn000.value = t.image;}
  |/*@bgen(jjtree) BOOL */
    {
      ASTBOOL jjtn002 = new ASTBOOL(JJTBOOL);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/ t = <BOOLEAN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/      /*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ {jjtn000.value = t.image;}
  |/*@bgen(jjtree) VOID */
    {
      ASTVOID jjtn003 = new ASTVOID(JJTVOID);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
    }
    try {
/*@egen*/ t = <VOID>/*@bgen(jjtree)*/
    } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003, true);
      }
    }
/*@egen*/      /*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

void parameter_list()             : {/*@bgen(jjtree) PARAMSLIST */
  ASTPARAMSLIST jjtn000 = new ASTPARAMSLIST(JJTPARAMSLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) PARAMSLIST */
  try {
/*@egen*/ //No void, want to see parameter_list Appear as a node
  (nemp_parameter_list())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void nemp_parameter_list()       : {}{ //dont want to create a node, its done in id() and type()
  id() <COLON> (type() [<COMMA> nemp_parameter_list()]) /**SHOULD I ADD #nemp_parameter_list(2) after this as its optional?**/
}

void main()       : {/*@bgen(jjtree) MAIN */
  ASTMAIN jjtn000 = new ASTMAIN(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) MAIN */
  try {
/*@egen*/
  [
  <MAIN>
  lchain()
    decl_list()
    statement_block()
  rchain()
  ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void statement_block()       : {}{
  (statement() statement_block())?
}

void statement()       : {}{ //Node will be created called statement
    id() 
    (/*@bgen(jjtree) EQUALS */
        {
          ASTEQUALS jjtn001 = new ASTEQUALS(JJTEQUALS);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
        <ASSIGN>/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/         expression() <SEMIC> 
      | <LBR> arg_list() <RBR> <SEMIC>
    ) 
  |/*@bgen(jjtree) OPENSTATEMENTBLOCK */
    {
      ASTOPENSTATEMENTBLOCK jjtn002 = new ASTOPENSTATEMENTBLOCK(JJTOPENSTATEMENTBLOCK);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/ lchain()/*@bgen(jjtree)*/
    } catch (Throwable jjte002) {
      if (jjtc002) {
        jjtree.clearNodeScope(jjtn002);
        jjtc002 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte002 instanceof RuntimeException) {
        throw (RuntimeException)jjte002;
      }
      if (jjte002 instanceof ParseException) {
        throw (ParseException)jjte002;
      }
      throw (Error)jjte002;
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/                     statement_block()/*@bgen(jjtree) CLOSESTATEMENTBLOCK */
                                                   {
                                                     ASTCLOSESTATEMENTBLOCK jjtn003 = new ASTCLOSESTATEMENTBLOCK(JJTCLOSESTATEMENTBLOCK);
                                                     boolean jjtc003 = true;
                                                     jjtree.openNodeScope(jjtn003);
                                                   }
                                                   try {
/*@egen*/ rchain()/*@bgen(jjtree)*/
                                                   } catch (Throwable jjte003) {
                                                     if (jjtc003) {
                                                       jjtree.clearNodeScope(jjtn003);
                                                       jjtc003 = false;
                                                     } else {
                                                       jjtree.popNode();
                                                     }
                                                     if (jjte003 instanceof RuntimeException) {
                                                       throw (RuntimeException)jjte003;
                                                     }
                                                     if (jjte003 instanceof ParseException) {
                                                       throw (ParseException)jjte003;
                                                     }
                                                     throw (Error)jjte003;
                                                   } finally {
                                                     if (jjtc003) {
                                                       jjtree.closeNodeScope(jjtn003, true);
                                                     }
                                                   }
/*@egen*/                     
  |/*@bgen(jjtree) IF */
    {
      ASTIF jjtn004 = new ASTIF(JJTIF);
      boolean jjtc004 = true;
      jjtree.openNodeScope(jjtn004);
    }
    try {
/*@egen*/ <IF>/*@bgen(jjtree)*/
    } finally {
      if (jjtc004) {
        jjtree.closeNodeScope(jjtn004, true);
      }
    }
/*@egen*/     condition() lchain() statement_block() rchain() [/*@bgen(jjtree) ELSE */
                                                              {
                                                                ASTELSE jjtn005 = new ASTELSE(JJTELSE);
                                                                boolean jjtc005 = true;
                                                                jjtree.openNodeScope(jjtn005);
                                                              }
                                                              try {
/*@egen*/<ELSE>/*@bgen(jjtree)*/
                                                              } finally {
                                                                if (jjtc005) {
                                                                  jjtree.closeNodeScope(jjtn005, true);
                                                                }
                                                              }
/*@egen*/       lchain() statement_block() rchain()] /*****OPTION TO ELSE???*****/
  |/*@bgen(jjtree) WHILE */
    {
      ASTWHILE jjtn006 = new ASTWHILE(JJTWHILE);
      boolean jjtc006 = true;
      jjtree.openNodeScope(jjtn006);
    }
    try {
/*@egen*/ <WHILE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc006) {
        jjtree.closeNodeScope(jjtn006, true);
      }
    }
/*@egen*/        condition() lchain() statement_block() rchain()
  | <SKIPSKIP> <SEMIC>
}

/***************************************************************************************************************/
/*******************************************EXPRESSION RULE*****************************************************/
/***************************************************************************************************************/

/*********************ORIGINAL***********************/
/*
void expression() : {}{
    fragment() binary_arith_op() fragment()
  | <LBR> expression() <RBR>
  | ID() <LBR> arg_list() <RBR>
  | fragment()
}
*/

void expression()       : {}{
    fragment() [binary_arith_op() expression()] 
}

void binary_arith_op()        : {/*@bgen(jjtree) BINOP */
                                 ASTBINOP jjtn000 = new ASTBINOP(JJTBINOP);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) BINOP */
    try {
/*@egen*//*@bgen(jjtree) PLUS */
    {
      ASTPLUS jjtn001 = new ASTPLUS(JJTPLUS);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    t = <PLUS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/      /*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {jjtn000.value = t.image;} 
    |/*@bgen(jjtree) MINUS */
      {
        ASTMINUS jjtn002 = new ASTMINUS(JJTMINUS);
        boolean jjtc002 = true;
        jjtree.openNodeScope(jjtn002);
      }
      try {
/*@egen*/ t = <MINUS>/*@bgen(jjtree)*/
      } finally {
        if (jjtc002) {
          jjtree.closeNodeScope(jjtn002, true);
        }
      }
/*@egen*/       /*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/*********************ORIGINAL***********************/
/*
void fragment() : {}{
    ID()
  | <MINUS> <ID>
  | <NUM>
  | <TRUE>
  | <FALSE>
  | expression()
}
*/

void fragment()       : {}{ //Insert Token t
    id()
    (
      [<LBR> arg_list() <RBR>]
    )
  |/*@bgen(jjtree) NUM */
    {
      ASTNUM jjtn001 = new ASTNUM(JJTNUM);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/ <NUM>/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/     
  |/*@bgen(jjtree) TRUE */
    {
      ASTTRUE jjtn002 = new ASTTRUE(JJTTRUE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
    }
    try {
/*@egen*/ <TRUE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
      }
    }
/*@egen*/      
  |/*@bgen(jjtree) FALSE */
    {
      ASTFALSE jjtn003 = new ASTFALSE(JJTFALSE);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
    }
    try {
/*@egen*/ <FALSE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003, true);
      }
    }
/*@egen*/       
  |/*@bgen(jjtree) MINUS */
    {
      ASTMINUS jjtn004 = new ASTMINUS(JJTMINUS);
      boolean jjtc004 = true;
      jjtree.openNodeScope(jjtn004);
    }
    try {
/*@egen*/ <MINUS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc004) {
        jjtree.closeNodeScope(jjtn004, true);
      }
    }
/*@egen*/        fragment()
}

/***************************************************************************************************************/
/*******************************************CONDITION RULE******************************************************/
/***************************************************************************************************************/

/*********************ORIGINAL***********************/
/*
void condition() : {}{
    <NOTOP> condition()
  | <LBR> condition() <RBR>
  | expression() comp_op() expression()
  | condition() <LBR> <OROP> | <ANDOP> <RBR> condition()
}
*/

/********************EDITED***************************/
void condition()       : {}{
    <NOTOP> condition() 
  | <LBR> condition() <RBR> [conditionPrime()]
  | expression() comp_op() expression() [conditionPrime()]
}

void conditionPrime()        : {/*@bgen(jjtree) ANDOR */
  ASTANDOR jjtn000 = new ASTANDOR(JJTANDOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) ANDOR */
  try {
/*@egen*/
  (<ANDOP> | <OROP>) condition()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void comp_op()         : {/*@bgen(jjtree) COMPOP */
                          ASTCOMPOP jjtn000 = new ASTCOMPOP(JJTCOMPOP);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) COMPOP */
    try {
/*@egen*/
    t = <BOOLEQLS>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <NOTEQLS>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <LESSTHAN>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <LESSEQL>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <GREATERTHAN>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ {jjtn000.value = t.image;}
  | t = <GREATEQL>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void arg_list()               : {/*@bgen(jjtree) ARGUMENTSLIST */
  ASTARGUMENTSLIST jjtn000 = new ASTARGUMENTSLIST(JJTARGUMENTSLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) ARGUMENTSLIST */
  try {
/*@egen*/
  (nemp_arg_list())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void nemp_arg_list()       : {}{
  id() [(<COMMA> nemp_arg_list())]
}

void id()     : {/*@bgen(jjtree) ID */
                 ASTID jjtn000 = new ASTID(JJTID);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;} {/*@bgen(jjtree) ID */
  try {
/*@egen*/
  t = <ID>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {jjtn000.value = t.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void lchain()         : {/*@bgen(jjtree) LCHAIN */
  ASTLCHAIN jjtn000 = new ASTLCHAIN(JJTLCHAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) LCHAIN */
  try {
/*@egen*/
  <LCHAIN>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void rchain()         :{/*@bgen(jjtree) RCHAIN */
  ASTRCHAIN jjtn000 = new ASTRCHAIN(JJTRCHAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) RCHAIN */
  try {
/*@egen*/
  <RCHAIN>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}