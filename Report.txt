I/We declare that this material, which I/We now submit for assessment, is entirely my/our
own work and has not been taken from the work of others, save and to the extent that such
work has been cited and acknowledged within the text of my/our work. I/We understand
that plagiarism, collusion, and copying are grave and serious offences in the university and
accept the penalties that would be imposed should I engage in plagiarism, collusion or
copying. I/We have read and understood the Assignment Regulations. I/We have identified
and included the source of all facts, ideas, opinions, and viewpoints of others in the
assignment references. Direct quotations from books, journal articles, internet sources,
module text, or any other source whatsoever are acknowledged and the source cited are
identified in the assignment references. This assignment, or any part of it, has not been
previously submitted by me/us or any other person for assessment on this or any other
course of study.
I/We have read and understood the referencing guidelines found at
http://www.dcu.ie/info/regulations/plagiarism.shtml , https://www4.dcu.ie/students/az/plagiarism
and/or recommended in the assignment guidelines.
Name(s): Stephen Cassedy Date: 12/12/16




/******Abstract Syntax Tree*******/
The first part of the assignment was based around building an abstract syntax tree. This would be a node-based representation of the structure
of the program. Child nodes would be indented from the parent node. E.g. Function() would be a child of Program() represented in the form:


																Program
																	Function
																		Type
																		ID
																		Params
																			X
																			Type
																			Y
																			Type

This represents a piece of code as such : integer multiply (x:integer , y:integer)
AST was generated by decorating the original production rules from the first assignment with the #Tag(x) where x is an integer of your choice.
Originally I had NODE_DEFAULT_VOID=false; set to True in the options section of the code but I later changed it to False as I felt I had more control
over the code when I could decorate everything myself, with the rule being voided or not. I tried to put in an adequate amount of detail in my AST as it
seemed up to my discression what to put in. Various refactoring had to be implemented to allow the AST to display nodes such as if (x > 0)  && y >= 0
in which case, as far as my understannding goes, should be displayed as:
	

																 Condition_Statement(if)
   																	And_Or(&&)
																		Comp_op(>)
																		 	Fragment
																		  		ID(x)
																			Fragment
																				 Num(0)
																		Comp_op(>=)
																		 	Fragment
																		  		ID(y)
																			Fragment
																		 		Num(0)

I achieved limted success in this but was plagued by index out of bounds errors while trying to create multiple child nodes for the likes of Condition_Statement() and Comp_op(). I had to transform many of the terminals into non-terminals by adding a production rule into the code, e.g. <INT> would be called by int() instead. This allowed me to decorate my rules more effectively.


/*******Symbol Table********/

#My Symbol Table does not include scope.

Without scope, the symbol table was seeming fairly straightforward to implements by implementing a hashtable and storing STC objects in it. This is done with the following code: 

													void num() #Num : {Token t;}{
														t = <NUM> {jjtThis.value = t.image; ST.put(t.image, new STC("Integer", t.image));}
													}

For the cases of variable and constant though, in their respective declaration functions, I wanted a qualifier to be printed out. I did this by creating a new STC object in STC.java that would take 3 parameters. This allowed a third feature in the symbol table which would act as 'var' or 'const'. This is declared in the jjt file as

													void var_decl() #Var_Decl : {Token t; String type; String id;}{
														t = <VARIABLE> id = identifier() <COLON> type = type() {jjtThis.value = t.image; ST.put(id, new STC(type, id, t.image));}
													}


/*******Print Visitor*******/
In PrintVisitor, I had to make visit() functions for all the decorations from the jjt file, e.g. #Num would produce an ASTNum node. In these functions, I printed out the node.value/node. This displayed the program in the form:

													Print Visitor:
													Program:
													Function integer multiply Params x integer y integer
													var result integer
													var minus_sign boolean if
													&&
													>
													x  0
													>=
													y  0
													minus_sign true
													x Negative x

I had intentions to use this with typechecker as a cross refernece and to print error messgaes but I ran out of time to complete the assignment so left it as is.