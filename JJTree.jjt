/**Set Options**/

options
{
  IGNORE_CASE = false;
  MULTI=true;
  VISITOR = true;
  NODE_DEFAULT_VOID=false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
}

PARSER_BEGIN(JJTree)

import java.io.*;
import java.util.*;

public class JJTree
{
  public static Hashtable ST = new Hashtable();

  public static void main(String[] args) throws ParseException, FileNotFoundException
  {
    String temp;
    STC temp2;

    if (args.length < 1)
    {
      System.out.println("Please pass in the filename.");
      System.exit(1);
    }

    JJTree parser = new JJTree(new FileInputStream(args[0]));

    SimpleNode root = parser.program();

    System.out.println("Abstract Syntax Tree:");

    root.dump(" ");
	
    System.out.println();
    System.out.println("Symbol Table:");

    Enumeration t = ST.keys();

    while (t.hasMoreElements())
    {
      temp = (String)t.nextElement();
      temp2 = (STC)ST.get(temp);
      System.out.println(temp);
      if (temp2.type != null)
      {
        System.out.println(" type = " + temp2.type);
      }
      if (temp2.value != null)
      {
        System.out.println(" value = " + temp2.value);
      }
      if(temp2.qualifier != null)
      	System.out.println(" qualifier = " + temp2.qualifier);
    }

    System.out.println();
    System.out.println("Print Visitor:");
    System.out.println("Program:");
    PrintVisitor pv = new PrintVisitor();
    root.jjtAccept(pv, null);
/*
    System.out.println();
    System.out.println("Type Checking:");
    TypeCheckVisitor tc = new TypeCheckVisitor();
    root.jjtAccept(tc, ST);
*/

  }
}

PARSER_END(JJTree)


/**Specify the Tokens For Lexical Analysis**/
TOKEN_MGR_DECLS :
{
static int commentNesting = 0;
}
SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
" "
| "\t"
| "\n"
| "\r"
| "\f"
| < "//" (~["\n"])* "\n" >
}
SKIP : /* COMMENTS */
{
"/*" { commentNesting++; } : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
		"/*" { commentNesting++; }
	| 	"*/" { commentNesting--;
	if (commentNesting == 0)
	SwitchTo(DEFAULT);
	}
	| <~[]>
}

TOKEN :{
		<COMMA : ",">
	|	<SEMIC : ";">
	|	<COLON : ":">
	|	<ASSIGN : "=">
	|	<LCHAIN : "{">
	|	<RCHAIN : "}">
	|	<LBR : "(">
	|	<RBR : ")">
	|	<PLUS : "+">
	|	<MINUS : "-">
	|	<UNDERSCORE : "_">
	|	<NOTOP : "~">
	|	<OROP : "||">
	|	<ANDOP : "&&">
	|	<BOOLEQLS : "==">
	|	<NOTEQLS : "!=">
	|	<LESSTHAN : "<">
	|	<GREATERTHAN : ">">
	|	<LESSEQL : "<=">
	|	<GREATEQL : ">=">
	|	<VARIABLE : "var">
	|	<CONSTANT : "const">
	|	<RETURN : "return">
	|	<INTEGER : "integer">
	|	<BOOLEAN : "boolean">
	|	<VOID : "void">
	|	<MAIN : "main">
	|	<IF : "if">
	|	<ELSE : "else">
	|	<TRUE : "true">
	|	<FALSE : "false">
	|	<WHILE : "while">
	|	<SKIPSKIP : "skip">
}

TOKEN :{
	  <NUM : (<DIGIT>) + >
	| < #DIGIT : ("-")? ["0" - "9"]>
	| <ID : <LETTER>(<LETTER> | <UNDERSCORE> | <DIGIT>)*>
	| < #LETTER : ["a" - "z", "A" - "Z"]>
}

TOKEN :{
	<OTHER : ~[]>
}

/**PRODUCTION RULES**/
SimpleNode program() #Program : {}{
	decl_list()
	function_list()
	main()
	<EOF>
	{return jjtThis;}
}

void decl_list() #void : {}{
	(decl() <SEMIC> decl_list())?
}

void decl() #void : {}{
	var_decl() | const_decl()
}

void var_decl() #Var_Decl : {Token t; String type; String id;}{
	t = <VARIABLE> id = identifier() <COLON> type = type() {jjtThis.value = t.image; ST.put(id, new STC(type, id, t.image));}
}

void const_decl() #Const_Decl : {Token t; String type; String id;}{
	t = <CONSTANT> id = identifier() <COLON> type = type() <ASSIGN> #Assign(2) expression() {jjtThis.value = t.image; ST.put(id, new STC(type, id, t.image));} 
}

void function_list() #void : {}{
	(function() function_list())?
}

void function() #Function : {}{
	type() identifier() <LBR> parameter_list() <RBR>
	<LCHAIN>
		decl_list()
		statement_block()
		<RETURN> <LBR> (expression())? <RBR> <SEMIC> #Function_Return(1)
	<RCHAIN>
}


String type() #Type : {Token t;}{
	t = <INTEGER> {jjtThis.value = t.image; return t.image;}
	| t = <BOOLEAN> {jjtThis.value = t.image; return t.image;} 
	| t = <VOID> {jjtThis.value = t.image; return t.image;}
}

void parameter_list() #Params : {}{
	(nemp_parameter_list())?
}

void nemp_parameter_list() #void : {}{
	identifier() <COLON> (type() [<COMMA> nemp_parameter_list()])
}

void main() #Main : {}{
	[
	<MAIN>
	<LCHAIN>
		decl_list()
		statement_block()
	<RCHAIN>
	]
}

void statement_block() #void : {}{
	(statement() statement_block())?
}

void statement() #void : {}{
		identifier()
		(
				<ASSIGN> expression() <SEMIC> #Assign(2)
			|	<LBR> arg_list() <RBR> <SEMIC>
		)
	|	<LCHAIN> statement_block() <RCHAIN>
	|	conditionStatement() condition() <LCHAIN> statement_block() <RCHAIN> [elseC() <LCHAIN> statement_block() <RCHAIN>]
//	|	whileC() condition() <LCHAIN> statement_block() <RCHAIN>
	|	<SKIPSKIP> <SEMIC>
//	|	<LBR> arg_list() <RBR> <SEMIC>
}

void elseC() #Else : {Token t;}{
	t = <ELSE> {jjtThis.value = t.image;}
}

void expression() #void : {}{
		fragment() [binary_arith_op() ]	
}

void binary_arith_op() #Bin_op(2) : {Token t;}{
		t = <PLUS> expression() {jjtThis.value = t.image;}
	|	t = <MINUS> expression() {jjtThis.value = t.image;}
}

void fragment() #Fragment(1) : {Token t;}{
		identifier()
		(
			[<LBR> arg_list() <RBR>]
		)
	|	num()
	|	bool()
	|	<MINUS> fragment() #Negative(1)
}

void condition() #void : {}{
		<NOTOP> condition() 
	|	<LBR> condition() <RBR> [conditionPrime()]
	|	expression() comp_op() expression() [conditionPrime()]
}

void conditionPrime() #And_Or(4) : {Token t;}{
	(	
		t = <ANDOP> {jjtThis.value = t.image;} 
	| 	t = <OROP> {jjtThis.value = t.image;}
	) condition()
}

void comp_op() #Comp_op(1) : {Token t;}{
		t = <BOOLEQLS> {jjtThis.value = t.image;}
	|	t = <NOTEQLS> {jjtThis.value = t.image;}
	|	t = <LESSTHAN> {jjtThis.value = t.image;}
	|	t = <LESSEQL> {jjtThis.value = t.image;}
	|	t = <GREATERTHAN> {jjtThis.value = t.image;}
	|	t = <GREATEQL> {jjtThis.value = t.image;}
}

void arg_list() #Args : {}{
	(nemp_arg_list())?
}

void nemp_arg_list() #void : {}{
	identifier() [(<COMMA> nemp_arg_list())]
}

String identifier() #ID : {Token t;}{
  t = <ID> {jjtThis.value = t.image; return t.image; ST.put(t.image, new STC("Identifier", t.image));}
}

void num() #Num : {Token t;}{
	t = <NUM> {jjtThis.value = t.image; ST.put(t.image, new STC("Integer", t.image));}
}

void bool() #Bool : {Token t;}{
	t = <TRUE> {jjtThis.value = t.image; ST.put(t.image, new STC("Boolean", t.image));}
	| t = <FALSE> {jjtThis.value = t.image; ST.put(t.image, new STC("Boolean", t.image));}
}

/*
void minus() #Minus : {Token t;}{
	t = <MINUS> {jjtThis.value = t.image;}
}
*/

void conditionStatement() #Condition_Statement : {Token t;}{
	t = <WHILE> {jjtThis.value = t.image;}
	| t = <IF> {jjtThis.value = t.image;}
	//| t = <ELSE> {jjtThis.value = t.image;}
}
